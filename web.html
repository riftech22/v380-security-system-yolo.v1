<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RIFTECH SECURITY SYSTEM</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Courier New', monospace;
            background: #0a0a0a;
            color: #00ff00;
            min-height: 100vh;
            overflow-x: hidden;
            position: relative;
        }

        /* Scanlines effect */
        body::before {
            content: "";
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            background: repeating-linear-gradient(
                0deg,
                rgba(0, 0, 0, 0.1),
                rgba(0, 0, 0, 0.1) 1px,
                transparent 1px,
                transparent 2px
            );
            z-index: 1000;
        }

        /* CRT flicker */
        @keyframes flicker {
            0%, 19%, 21%, 23%, 25%, 54%, 56%, 100% {
                opacity: 1;
            }
            20%, 24%, 55% {
                opacity: 0.9;
            }
        }

        body::after {
            content: "";
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            background: rgba(0, 0, 0, 0.02);
            animation: flicker 0.15s infinite;
            z-index: 999;
        }
        
        .container {
            max-width: 1920px;
            margin: 0 auto;
            padding: 10px;
            display: grid;
            grid-template-columns: 1fr 380px;
            gap: 20px;
            height: auto;
            min-height: calc(100vh - 20px);
        }
        
        /* Tablet Layout */
        @media (max-width: 1200px) {
            .container {
                grid-template-columns: 1fr;
                gap: 15px;
                padding: 10px;
            }
            
            .status-bar {
                gap: 5px;
            }
            
            .status-item {
                min-width: 80px;
                padding: 6px 8px;
                font-size: 0.75em;
            }
            
            .status-display {
                gap: 20px;
                padding: 12px 15px;
            }
            
            .status-icon-large {
                font-size: 1.5em;
            }
            
            .status-text-large {
                font-size: 1em;
            }
            
            .controls-grid {
                grid-template-columns: 1fr;
            }
            
            .controls-grid.single {
                grid-template-columns: 1fr;
            }
            
            button {
                padding: 8px 12px;
                font-size: 11px;
            }
        }
        
        /* Mobile Layout */
        @media (max-width: 768px) {
            .container {
                padding: 5px;
                gap: 10px;
            }
            
            header {
                padding: 10px 8px;
                margin-bottom: 8px;
            }
            
            h1 {
                font-size: 1.3em;
                letter-spacing: 1px;
            }
            
            .subtitle {
                font-size: 0.7em;
                letter-spacing: 1px;
            }
            
            .status-bar {
                gap: 4px;
                margin-top: 8px;
            }
            
            .status-item {
                min-width: 60px;
                padding: 4px 6px;
                font-size: 0.65em;
                gap: 4px;
            }
            
            .status-icon {
                font-size: 0.9em;
            }
            
            .status-label {
                font-size: 0.6em;
            }
            
            .status-value {
                font-size: 0.9em;
            }
            
            .video-section {
                min-height: 300px;
                border-width: 1px;
            }
            
            .status-display {
                gap: 15px;
                padding: 10px;
                flex-wrap: wrap;
            }
            
            .status-display-item {
                min-width: 100px;
                gap: 8px;
            }
            
            .status-icon-large {
                font-size: 1.3em;
            }
            
            .status-text-large {
                font-size: 0.9em;
                letter-spacing: 1px;
            }
            
            .panel {
                padding: 10px 12px;
                margin-bottom: 10px;
                border-width: 1px;
            }
            
            .panel h3 {
                font-size: 0.8em;
                gap: 6px;
                padding-bottom: 6px;
            }
            
            .panel h3 .icon {
                font-size: 1.1em;
            }
            
            button {
                padding: 8px 10px;
                font-size: 10px;
                min-height: 36px;
                gap: 6px;
            }
            
            .toggle-indicator {
                width: 16px;
                height: 16px;
            }
            
            .toggle-indicator::before {
                width: 8px;
                height: 8px;
            }
            
            select, input[type="range"] {
                padding: 8px;
                font-size: 12px;
            }
            
            .logs {
                max-height: 200px;
                padding: 10px;
            }
            
            .log-entry {
                padding: 6px 8px;
                font-size: 11px;
            }
            
            .log-time {
                min-width: 60px;
                font-size: 10px;
            }
            
            .connection-status {
                padding: 10px;
                font-size: 0.9em;
                margin-bottom: 12px;
            }
        }
        
        /* Small Mobile Layout */
        @media (max-width: 480px) {
            .container {
                padding: 3px;
                gap: 8px;
            }
            
            h1 {
                font-size: 1.1em;
                letter-spacing: 0.5px;
            }
            
            .subtitle {
                font-size: 0.6em;
            }
            
            .status-bar {
                gap: 3px;
            }
            
            .status-item {
                min-width: 50px;
                padding: 3px 5px;
                font-size: 0.6em;
            }
            
            .status-icon {
                font-size: 0.8em;
            }
            
            .status-label {
                display: none;
            }
            
            .status-value {
                font-size: 0.85em;
            }
            
            .video-section {
                min-height: 200px;
            }
            
            .status-display {
                gap: 10px;
                padding: 8px;
            }
            
            .status-display-item {
                min-width: 80px;
                flex-direction: column;
                gap: 4px;
            }
            
            .status-icon-large {
                font-size: 1.1em;
            }
            
            .status-text-large {
                font-size: 0.75em;
            }
            
            .panel {
                padding: 8px 10px;
                margin-bottom: 8px;
            }
            
            .panel h3 {
                font-size: 0.7em;
            }
            
            button {
                padding: 6px 8px;
                font-size: 9px;
                min-height: 32px;
                flex-direction: column;
                gap: 4px;
            }
            
            .toggle-indicator {
                width: 14px;
                height: 14px;
            }
            
            .toggle-indicator::before {
                width: 8px;
                height: 8px;
            }
            
            .logs {
                max-height: 150px;
                padding: 8px;
            }
            
            .log-entry {
                padding: 4px 6px;
                font-size: 10px;
            }
            
            .modal-content {
                padding: 15px;
            }
            
            .modal-content h2 {
                font-size: 1.2em;
            }
        }
        
        /* Header */
        header {
            grid-column: 1 / -1;
            text-align: center;
            padding: 15px 20px;
            background: rgba(0, 255, 0, 0.05);
            border-radius: 0;
            margin-bottom: 10px;
            border: 2px solid #00ff00;
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.3), inset 0 0 20px rgba(0, 255, 0, 0.05);
            position: relative;
            overflow: hidden;
        }

        header::before {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 2px;
            background: linear-gradient(90deg, transparent, #00ff00, #00ffff, #ff00ff, #00ff00, transparent);
            animation: scanline 2s linear infinite;
        }

        @keyframes scanline {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }

        h1 {
            font-size: 2em;
            margin-bottom: 5px;
            text-shadow: 
                0 0 10px #00ff00,
                0 0 20px #00ff00,
                0 0 30px #00ff00,
                0 0 40px #00ffff;
            letter-spacing: 3px;
            color: #00ff00;
            animation: glow 2s ease-in-out infinite alternate;
        }

        @keyframes glow {
            from {
                text-shadow: 
                    0 0 10px #00ff00,
                    0 0 20px #00ff00,
                    0 0 30px #00ff00,
                    0 0 40px #00ffff;
            }
            to {
                text-shadow: 
                    0 0 20px #00ffff,
                    0 0 30px #00ffff,
                    0 0 40px #00ffff,
                    0 0 50px #ff00ff;
            }
        }

        .subtitle {
            color: #00ffff;
            font-size: 0.9em;
            text-transform: uppercase;
            letter-spacing: 2px;
            text-shadow: 0 0 10px #00ffff;
        }
        
        /* Status Bar */
        .status-bar {
            display: flex;
            justify-content: center;
            gap: 8px;
            flex-wrap: wrap;
            margin-top: 12px;
        }
        
        .status-item {
            background: rgba(0, 0, 0, 0.85);
            padding: 8px 14px;
            border-radius: 0;
            border: 1px solid #00ff00;
            display: flex;
            align-items: center;
            gap: 8px;
            min-width: 110px;
            justify-content: center;
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.3);
            font-size: 0.85em;
        }

        .status-item:hover {
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.5);
            border-color: #00ffff;
            transform: translateY(-2px);
        }
        
        .status-icon {
            font-size: 1.1em;
        }
        
        .status-label {
            font-size: 0.75em;
            color: #00ffff;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .status-value {
            color: #00ff00;
            font-weight: bold;
            font-size: 1em;
            text-shadow: 0 0 10px #00ff00;
        }
        
        .status-value.warning {
            color: #ffff00;
        }
        
        .status-value.danger {
            color: #ff0000;
        }
        
        /* Video Container */
        .video-section {
            background: rgba(0, 0, 0, 0.9);
            border-radius: 0;
            overflow: hidden;
            border: 2px solid #00ff00;
            box-shadow: 
                0 0 20px rgba(0, 255, 0, 0.5),
                inset 0 0 50px rgba(0, 0, 0, 0.5);
            position: relative;
            min-height: 500px;
        }

        .video-section::before {
            content: "";
            position: absolute;
            top: -2px;
            left: -2px;
            right: -2px;
            bottom: -2px;
            background: 
                linear-gradient(90deg, #00ff00, #00ffff, #ff00ff, #00ff00),
                linear-gradient(90deg, #00ff00, #00ffff, #ff00ff, #00ff00);
            background-size: 100% 2px, 2px 100%;
            background-repeat: no-repeat;
            background-position: 0 0, 0 0;
            pointer-events: none;
            animation: border-pulse 4s linear infinite;
        }

        @keyframes border-pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        #video-feed {
            width: 100%;
            display: block;
            background: #000;
        }
        
        #zone-canvas-top {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 50%;
            cursor: crosshair;
            z-index: 20;
            pointer-events: auto;
        }
        
        #zone-canvas-bottom {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 50%;
            cursor: crosshair;
            z-index: 20;
            pointer-events: auto;
        }
        
        #overlay-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 30;
            pointer-events: none;
        }
        
        .status-display {
            grid-column: 1 / -1;
            background: rgba(0, 0, 0, 0.95);
            border: 2px solid #00ff00;
            border-radius: 0;
            padding: 15px 20px;
            margin-bottom: 15px;
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.4);
            display: flex;
            justify-content: center;
            gap: 40px;
        }
        
        .status-display:hover {
            border-color: #00ffff;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.6);
        }
        
        .status-display-item {
            display: flex;
            align-items: center;
            gap: 12px;
            min-width: 150px;
        }
        
        .status-icon-large {
            font-size: 2em;
            text-shadow: 0 0 10px #00ff00;
        }
        
        .status-text-large {
            font-size: 1.2em;
            font-weight: bold;
            color: #00ff00;
            text-transform: uppercase;
            letter-spacing: 2px;
            text-shadow: 0 0 10px #00ff00;
        }
        
        .status-text-large.armed {
            color: #00ff00;
            text-shadow: 0 0 10px #00ff00;
        }
        
        .status-text-large.disarmed {
            color: #ff0000;
            text-shadow: 0 0 10px #ff0000;
        }
        
        .status-text-large.breach {
            color: #ff0000;
            animation: pulse 0.5s infinite;
        }
        
        /* Control Panels */
        .panel {
            background: rgba(0, 0, 0, 0.9);
            border-radius: 0;
            padding: 12px 15px;
            margin-bottom: 12px;
            border: 1px solid #00ff00;
            box-shadow: 0 0 15px rgba(0, 255, 0, 0.2);
        }

        .panel:hover {
            box-shadow: 0 0 25px rgba(0, 255, 0, 0.4);
            border-color: #00ffff;
        }
        
        .panel h3 {
            margin-bottom: 10px;
            padding-bottom: 8px;
            border-bottom: 2px solid #00ff00;
            display: flex;
            align-items: center;
            gap: 8px;
            color: #00ffff;
            font-size: 0.9em;
            text-transform: uppercase;
            letter-spacing: 2px;
            text-shadow: 0 0 10px #00ffff;
        }
        
        .panel h3 .icon {
            font-size: 1.3em;
        }
        
        /* Controls Grid */
        .controls-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
        }
        
        .controls-grid.single {
            grid-template-columns: 1fr;
        }
        
        button {
            background: rgba(0, 0, 0, 0.9);
            color: #00ff00;
            border: 2px solid #00ff00;
            border-radius: 0;
            padding: 10px 15px;
            font-size: 12px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            min-height: 40px;
            text-transform: uppercase;
            letter-spacing: 1px;
            position: relative;
            overflow: hidden;
        }

        button::before {
            content: "";
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(0, 255, 0, 0.3), transparent);
            transition: left 0.5s;
        }

        button:hover::before {
            left: 100%;
        }
        
        button:hover {
            background: rgba(0, 255, 0, 0.1);
            border-color: #00ffff;
            box-shadow: 0 0 30px rgba(0, 255, 0, 0.6);
            transform: translateY(-2px);
            color: #00ffff;
        }
        
        button:active {
            transform: translateY(0);
        }
        
        button.active {
            background: rgba(255, 0, 255, 0.1);
            border-color: #ff00ff;
            color: #ff00ff;
            text-shadow: 0 0 10px #ff00ff;
            box-shadow: 0 0 30px rgba(255, 0, 255, 0.6);
        }
        
        button.danger {
            background: rgba(255, 0, 0, 0.1);
            border-color: #ff0000;
            color: #ff0000;
            text-shadow: 0 0 10px #ff0000;
        }
        
        button.danger:hover {
            border-color: #ff4444;
            box-shadow: 0 0 30px rgba(255, 0, 0, 0.8);
            color: #ff4444;
        }
        
        /* Toggle Buttons */
        .toggle-btn {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .toggle-indicator {
            width: 20px;
            height: 20px;
            border-radius: 0;
            background: #0a0a0a;
            border: 2px solid #333;
            transition: all 0.3s;
            position: relative;
        }

        .toggle-indicator::before {
            content: "";
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 10px;
            height: 10px;
            background: #333;
            transition: all 0.3s;
        }
        
        .toggle-indicator.on {
            background: rgba(0, 255, 0, 0.2);
            border-color: #00ff00;
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.8), inset 0 0 20px rgba(0, 255, 0, 0.2);
        }

        .toggle-indicator.on::before {
            background: #00ff00;
            box-shadow: 0 0 10px #00ff00;
        }
        
        /* Select/Inputs */
        select, input[type="range"] {
            width: 100%;
            padding: 10px;
            background: rgba(0, 0, 0, 0.9);
            border: 1px solid #00ff00;
            border-radius: 0;
            color: #00ff00;
            font-size: 14px;
            margin: 5px 0;
            font-family: 'Courier New', monospace;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        select:focus, input:focus {
            outline: none;
            border-color: #00ffff;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
        }
        
        select option {
            background: #0a0a0a;
            color: #00ff00;
        }

        select:hover {
            cursor: pointer;
        }
        
        /* Range Slider */
        input[type="range"] {
            -webkit-appearance: none;
            height: 8px;
            background: #1a1a4a;
            border-radius: 4px;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #00ffff;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
        }
        
        /* Logs */
        .logs {
            max-height: 300px;
            overflow-y: auto;
            background: rgba(0, 0, 0, 0.95);
            border-radius: 0;
            padding: 15px;
            border: 1px solid #00ff00;
            box-shadow: inset 0 0 30px rgba(0, 0, 0, 0.5);
        }
        
        .log-entry {
            padding: 8px 12px;
            margin: 5px 0;
            border-left: 3px solid #00ff00;
            background: rgba(0, 255, 0, 0.05);
            font-family: 'Courier New', monospace;
            font-size: 13px;
            display: flex;
            gap: 10px;
            align-items: flex-start;
        }

        .log-entry:hover {
            background: rgba(0, 255, 0, 0.1);
        }
        
        .log-time {
            color: #00ffff;
            min-width: 80px;
            text-shadow: 0 0 5px #00ffff;
        }
        
        .log-message {
            color: #00ff00;
            flex: 1;
            text-shadow: 0 0 5px #00ff00;
        }
        
        .log-entry.error {
            border-left-color: #ff0000;
            background: rgba(255, 0, 0, 0.05);
        }
        
        .log-entry.warning {
            border-left-color: #ffff00;
            background: rgba(255, 255, 0, 0.05);
        }
        
        .log-entry.success {
            border-left-color: #00ff00;
            background: rgba(0, 255, 0, 0.05);
        }
        
        /* Connection Status */
        .connection-status {
            text-align: center;
            padding: 15px;
            margin-bottom: 20px;
            border-radius: 0;
            font-weight: bold;
            font-size: 1.1em;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        
        .connection-status.connected {
            background: rgba(0, 255, 0, 0.1);
            border: 2px solid #00ff00;
            color: #00ff00;
            text-shadow: 0 0 10px #00ff00;
            box-shadow: 0 0 30px rgba(0, 255, 0, 0.5), inset 0 0 30px rgba(0, 255, 0, 0.1);
            animation: connected-pulse 2s infinite;
        }

        @keyframes connected-pulse {
            0%, 100% {
                box-shadow: 0 0 30px rgba(0, 255, 0, 0.5), inset 0 0 30px rgba(0, 255, 0, 0.1);
            }
            50% {
                box-shadow: 0 0 50px rgba(0, 255, 0, 0.8), inset 0 0 50px rgba(0, 255, 0, 0.15);
            }
        }
        
        .connection-status.disconnected {
            background: rgba(255, 0, 0, 0.1);
            border: 2px solid #ff0000;
            color: #ff0000;
            text-shadow: 0 0 10px #ff0000;
            box-shadow: 0 0 30px rgba(255, 0, 0, 0.5), inset 0 0 30px rgba(255, 0, 0, 0.1);
            animation: disconnected-pulse 0.5s infinite;
        }

        @keyframes disconnected-pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 10px;
        }
        
        ::-webkit-scrollbar-track {
            background: #0a0a0a;
        }
        
        ::-webkit-scrollbar-thumb {
            background: #00ff00;
            border-radius: 0;
        }
        
        ::-webkit-scrollbar-thumb:hover {
            background: #00ffff;
        }
        
        /* Zone Drawing Mode */
        .drawing-mode {
            cursor: crosshair;
        }
        
        .drawing-mode .video-section {
            border-color: #ff00ff;
            box-shadow: 0 0 50px rgba(255, 0, 255, 0.8), inset 0 0 50px rgba(255, 0, 255, 0.2);
            animation: drawing-pulse 1s infinite;
        }

        @keyframes drawing-pulse {
            0%, 100% {
                box-shadow: 0 0 50px rgba(255, 0, 255, 0.8), inset 0 0 50px rgba(255, 0, 255, 0.2);
            }
            50% {
                box-shadow: 0 0 80px rgba(255, 0, 255, 1), inset 0 0 80px rgba(255, 0, 255, 0.3);
            }
        }
        
        /* Snapshot Modal */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }
        
        .modal.show {
            display: flex;
        }
        
        .modal-content {
            background: rgba(0, 0, 0, 0.95);
            border-radius: 0;
            padding: 30px;
            border: 2px solid #00ff00;
            max-width: 90%;
            max-height: 90%;
            overflow: auto;
            box-shadow: 0 0 50px rgba(0, 255, 0, 0.5);
        }

        .modal-content h2 {
            text-shadow: 0 0 20px #00ff00;
            letter-spacing: 3px;
        }
        
        .modal-content img {
            max-width: 100%;
            border-radius: 10px;
            margin-bottom: 20px;
        }
        
        .modal-close {
            position: absolute;
            top: 20px;
            right: 20px;
            background: #ff0000;
            color: #fff;
            border: none;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>RIFTECH SECURITY SYSTEM</h1>
            <p class="subtitle">Advanced AI-Powered Monitoring System</p>
            
            <div class="status-bar">
                <div class="status-item">
                    <span class="status-icon">üì°</span>
                    <span class="status-label">Connection:</span>
                    <span id="connection-status" class="status-value">Disconnected</span>
                </div>
                <div class="status-item">
                    <span class="status-icon">üë•</span>
                    <span class="status-label">Clients:</span>
                    <span id="client-count" class="status-value">0</span>
                </div>
                <div class="status-item">
                    <span class="status-icon">üë§</span>
                    <span class="status-label">Persons:</span>
                    <span id="person-count" class="status-value">0</span>
                </div>
                <div class="status-item">
                    <span class="status-icon">üö®</span>
                    <span class="status-label">Alerts:</span>
                    <span id="alert-count" class="status-value">0</span>
                </div>
                <div class="status-item">
                    <span class="status-icon">üé¨</span>
                    <span class="status-label">Recording:</span>
                    <span id="recording-status" class="status-value">Off</span>
                </div>
                <div class="status-item">
                    <span class="status-icon">üîí</span>
                    <span class="status-label">Zone:</span>
                    <span id="zone-status" class="status-value">Clear</span>
                </div>
                <div class="status-item">
                    <span class="status-icon">‚è±Ô∏è</span>
                    <span class="status-label">FPS:</span>
                    <span id="fps-counter" class="status-value">0</span>
                </div>
            </div>
        </header>
        
        <!-- Video Section -->
        <div class="video-section">
            <img id="video-feed" alt="Security Camera Feed" />
            <canvas id="zone-canvas-top"></canvas>
            <canvas id="zone-canvas-bottom"></canvas>
            <canvas id="overlay-canvas"></canvas>
        </div>
        
        <!-- Status Display (OUTSIDE live preview) -->
        <div class="status-display">
            <div class="status-display-item">
                <span class="status-icon-large">üîí</span>
                <span class="status-text-large" id="arm-status-display">DISARMED</span>
            </div>
            <div class="status-display-item">
                <span class="status-icon-large">‚ö†Ô∏è</span>
                <span class="status-text-large" id="breach-duration-display">0s</span>
            </div>
            <div class="status-display-item">
                <span class="status-icon-large">üéØ</span>
                <span class="status-text-large" id="zone-count-display">0 zones</span>
            </div>
        </div>
        
        <!-- Control Panels -->
        <div class="control-section">
            <div class="connection-status disconnected" id="connection-alert">
                ‚ö†Ô∏è Disconnected from server. Reconnecting...
            </div>
            
            <!-- Main Controls -->
            <div class="panel">
                <h3><span class="icon">‚ö°</span> CONTROLS</h3>
                <div class="controls-grid">
                    <button id="arm-btn" onclick="toggleArm()">
                        <div class="toggle-indicator" id="arm-indicator"></div>
                        <span id="arm-btn-text">ARM SYSTEM</span>
                    </button>
                    <button id="record-btn" onclick="toggleRecord()">
                        <div class="toggle-indicator" id="record-indicator"></div>
                        <span id="record-btn-text">RECORD</span>
                    </button>
                    <button onclick="takeSnapshot()">
                        üì∏ SNAPSHOT
                    </button>
                    <button id="mute-btn" onclick="toggleMute()">
                        <div class="toggle-indicator" id="mute-indicator"></div>
                        <span id="mute-btn-text">MUTE</span>
                    </button>
                </div>
            </div>
            
            <!-- Detection Settings -->
            <div class="panel">
                <h3><span class="icon">üéØ</span> DETECTION</h3>
                
                <div style="margin-bottom: 15px;">
                    <label style="display: block; margin-bottom: 5px; color: #8080ff;">Confidence Level:</label>
                    <select id="confidence-select" onchange="setConfidence()">
                        <option value="0.15">15% (High Sensitivity)</option>
                        <option value="0.20">20% (High)</option>
                        <option value="0.25" selected>25% (Medium)</option>
                        <option value="0.30">30% (Medium)</option>
                        <option value="0.40">40% (Low)</option>
                        <option value="0.50">50% (Low)</option>
                    </select>
                </div>
                
                <div style="margin-bottom: 15px;">
                    <label style="display: block; margin-bottom: 5px; color: #8080ff;">YOLO Model:</label>
                    <select id="model-select" onchange="setModel()">
                        <option value="yolov8n.pt" selected>YOLOv8 Nano (Fast)</option>
                        <option value="yolov8s.pt">YOLOv8 Small (Balanced)</option>
                        <option value="yolov8m.pt">YOLOv8 Medium (Accurate)</option>
                    </select>
                </div>
                
                <div class="controls-grid single">
                    <button id="skeleton-btn" onclick="toggleSkeleton()">
                        <div class="toggle-indicator" id="skeleton-indicator"></div>
                        <span>ü¶¥ Skeleton Detection</span>
                    </button>
                    <button id="face-btn" onclick="toggleFace()">
                        <div class="toggle-indicator on" id="face-indicator"></div>
                        <span>üë§ Face Recognition</span>
                    </button>
                    <button id="motion-btn" onclick="toggleMotion()">
                        <div class="toggle-indicator on" id="motion-indicator"></div>
                        <span>üì° Motion Detection</span>
                    </button>
                    <button id="heatmap-btn" onclick="toggleHeatmap()">
                        <div class="toggle-indicator" id="heatmap-indicator"></div>
                        <span>üî• Heat Map</span>
                    </button>
                    <button id="night-btn" onclick="toggleNightVision()">
                        <div class="toggle-indicator" id="night-indicator"></div>
                        <span>üåô Night Vision</span>
                    </button>
                </div>
            </div>
            
            <!-- Zone Management -->
            <div class="panel">
                <h3><span class="icon">üéØ</span> ZONES</h3>
                <div class="controls-grid">
                    <button onclick="createZone()">
                        ‚ûï NEW ZONE
                    </button>
                    <button id="draw-btn" onclick="toggleDrawMode()">
                        <div class="toggle-indicator" id="draw-indicator"></div>
                        <span>‚úèÔ∏è DRAW</span>
                    </button>
                </div>
                <div class="overlay-item" style="margin: 10px 0; font-size: 0.85em;">
                    <span>üìç</span>
                    <span>Zones: <span id="zones-count-panel">0</span> | Points: <span id="zone-points-count">0</span></span>
                </div>
                <p style="margin: 10px 0; color: #00ffff; font-size: 0.8em; text-transform: uppercase; letter-spacing: 1px;">
                    [INFO] Top canvas (0-50% height) untuk kamera atas. Bottom canvas (50-100% height) untuk kamera bawah.
                </p>
                <button class="danger" onclick="clearZones()">
                    üóëÔ∏è CLEAR ALL ZONES
                </button>
            </div>
            
            <!-- Trusted Faces -->
            <div class="panel">
                <h3><span class="icon">üë§</span> TRUSTED FACES</h3>
                <div class="overlay-item" style="margin-bottom: 15px;">
                    <span>üì∑</span>
                    <span>Loaded: <span id="faces-count">0</span> faces</span>
                </div>
                <button onclick="reloadFaces()">
                    üîÑ RELOAD FACES
                </button>
            </div>
            
            <!-- Statistics -->
            <div class="panel">
                <h3><span class="icon">üìä</span> STATISTICS</h3>
                <div class="controls-grid single">
                    <div class="overlay-item">
                        <span>‚è±Ô∏è</span>
                        <span>Breach Duration: <span id="breach-duration-stat">0s</span></span>
                    </div>
                    <div class="overlay-item">
                        <span>üë•</span>
                        <span>Connected Clients: <span id="clients-stat">0</span></span>
                    </div>
                </div>
            </div>
            
            <!-- Activity Log -->
            <div class="panel">
                <h3><span class="icon">üìã</span> ACTIVITY LOG</h3>
                <div class="logs" id="log-container">
                    <div class="log-entry">
                        <span class="log-time">System</span>
                        <span class="log-message">Initializing web interface...</span>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Snapshot Modal -->
    <div class="modal" id="snapshot-modal">
        <button class="modal-close" onclick="closeSnapshotModal()">√ó</button>
        <div class="modal-content">
            <h2 style="margin-bottom: 20px; color: #00ff00; text-transform: uppercase; letter-spacing: 3px;">üì∏ SNAPSHOT</h2>
            <img id="snapshot-image" alt="Snapshot" />
            <p id="snapshot-time" style="color: #00ffff; margin-top: 10px; text-transform: uppercase;"></p>
        </div>
    </div>

    <script>
        const WS_URL = `ws://${window.location.hostname}:8765`;
        let ws = null;
        let connected = false;
        
        let frameCount = 0;
        let fpsTimer = null;
        let lastFrameTime = Date.now();
        
        // State with localStorage persistence
        let isDrawing = false;
        let zonePoints = [];
        let serverZones = []; // Zones from server
        let savedState = {
            armed: false,
            skeleton: false,
            face: true,
            motion: true,
            heatmap: false,
            night_vision: false
        };
        
        // Canvas dimensions - will be set when video loads
        let canvasWidth = 1280;
        let canvasHeight = 720;
        let videoNaturalWidth = 1280;
        let videoNaturalHeight = 720;
        
        // Split camera detection
        let isSplitFrame = false;
        let splitY = 0;
        let topCanvasHeight = 0;
        let bottomCanvasHeight = 0;
        
        // Load saved state from localStorage
        function loadSavedState() {
            try {
                const saved = localStorage.getItem('riftech_security_state');
                if (saved) {
                    savedState = JSON.parse(saved);
                    console.log('[State] Loaded from localStorage:', savedState);
                }
            } catch (e) {
                console.error('[State] Error loading saved state:', e);
            }
        }
        
        // Save state to localStorage
        function saveState() {
            try {
                localStorage.setItem('riftech_security_state', JSON.stringify(savedState));
                console.log('[State] Saved to localStorage:', savedState);
            } catch (e) {
                console.error('[State] Error saving state:', e);
            }
        }
        
        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            loadSavedState();
            applySavedState();
            setupCanvas();
            connectWebSocket();
        });
        
        function setupCanvas() {
            const zoneCanvasTop = document.getElementById('zone-canvas-top');
            const zoneCanvasBottom = document.getElementById('zone-canvas-bottom');
            const overlayCanvas = document.getElementById('overlay-canvas');
            const video = document.getElementById('video-feed');
            
            // Set initial canvas sizes
            zoneCanvasTop.width = canvasWidth;
            zoneCanvasTop.height = canvasHeight;
            zoneCanvasBottom.width = canvasWidth;
            zoneCanvasBottom.height = canvasHeight;
            overlayCanvas.width = canvasWidth;
            overlayCanvas.height = canvasHeight;
            
            // Update canvas size when video loads
            video.onload = () => {
                if (video.naturalWidth && video.naturalHeight) {
                    videoNaturalWidth = video.naturalWidth;
                    videoNaturalHeight = video.naturalHeight;
                    canvasWidth = video.naturalWidth;
                    canvasHeight = video.naturalHeight;
                    
                    // Detect split frame (V380 vertical stack)
                    isSplitFrame = (video.naturalWidth < video.naturalHeight * 0.9);
                    splitY = Math.round(video.naturalHeight / 2);
                    topCanvasHeight = splitY;
                    bottomCanvasHeight = video.naturalHeight - splitY;
                    
                    if (isSplitFrame) {
                        // Top canvas: full width, half height
                        zoneCanvasTop.width = video.naturalWidth;
                        zoneCanvasTop.height = topCanvasHeight;
                        
                        // Bottom canvas: full width, half height
                        zoneCanvasBottom.width = video.naturalWidth;
                        zoneCanvasBottom.height = bottomCanvasHeight;
                        
                        console.log(`[Canvas] Split frame detected: ${video.naturalWidth}x${video.naturalHeight}`);
                        console.log(`[Canvas] Top canvas: ${zoneCanvasTop.width}x${zoneCanvasTop.height} (top split)`);
                        console.log(`[Canvas] Bottom canvas: ${zoneCanvasBottom.width}x${zoneCanvasBottom.height} (bottom split)`);
                        addLog(`Split frame: Top ${zoneCanvasTop.width}x${zoneCanvasTop.height}, Bottom ${zoneCanvasBottom.width}x${zoneCanvasBottom.height}`, 'info');
                    } else {
                        // Single camera: full canvas
                        zoneCanvasTop.width = video.naturalWidth;
                        zoneCanvasTop.height = video.naturalHeight;
                        zoneCanvasBottom.width = video.naturalWidth;
                        zoneCanvasBottom.height = video.naturalHeight;
                        
                        console.log(`[Canvas] Single camera: ${video.naturalWidth}x${video.naturalHeight}`);
                        addLog(`Single camera detected: ${video.naturalWidth}x${video.naturalHeight}`, 'info');
                    }
                    
                    canvasWidth = video.naturalWidth;
                    canvasHeight = video.naturalHeight;
                    
                    // Overlay canvas always full size
                    overlayCanvas.width = video.naturalWidth;
                    overlayCanvas.height = video.naturalHeight;
                    
                    console.log(`[Canvas] Video loaded: ${video.naturalWidth}x${video.naturalHeight}`);
                    addLog(`Canvas resized to ${canvasWidth}x${canvasHeight}`, 'info');
                }
            };
            
            // Add click event to both zone canvases
            zoneCanvasTop.addEventListener('click', (e) => {
                if (isDrawing) {
                    addZonePoint(e, 'top');
                }
            });
            
            zoneCanvasBottom.addEventListener('click', (e) => {
                if (isDrawing) {
                    addZonePoint(e, 'bottom');
                }
            });
        }
        
        function connectWebSocket() {
            ws = new WebSocket(WS_URL);
            
            ws.onopen = () => {
                connected = true;
                updateConnectionUI();
                addLog('Connected to server', 'success');
                requestStatus();
                startFPSCounter();
            };
            
            ws.onclose = () => {
                connected = false;
                updateConnectionUI();
                addLog('Disconnected from server', 'error');
                stopFPSCounter();
                setTimeout(connectWebSocket, 3000);
            };
            
            ws.onerror = (error) => {
                console.error('[WebSocket] Error:', error);
                addLog('WebSocket error occurred', 'error');
            };
            
            ws.onmessage = (event) => {
                try {
                    const message = JSON.parse(event.data);
                    handleMessage(message);
                } catch (e) {
                    console.error('[WebSocket] Error parsing message:', e);
                }
            };
        }
        
        function handleMessage(message) {
            switch (message.type) {
                case 'frame':
                    updateVideoFeed(message.data);
                    frameCount++;
                    break;
                    
                case 'status':
                    updateStatus(message);
                    break;
                    
                case 'snapshot':
                    if (message.data) {
                        showSnapshot(message.data);
                    } else {
                        addLog('Snapshot data is empty', 'error');
                    }
                    break;
                    
                case 'error':
                    addLog(`Server error: ${message.message}`, 'error');
                    alert(`Snapshot Error: ${message.message}`);
                    break;
                    
                case 'zones':
                    updateZones(message.zones);
                    break;
            }
        }
        
        function updateZones(zones) {
            console.log('[Zone] Server zones updated:', zones);
            serverZones = zones;
            drawAllZones();
        }
        
        function drawAllZones() {
            const zoneCanvasTop = document.getElementById('zone-canvas-top');
            const zoneCanvasBottom = document.getElementById('zone-canvas-bottom');
            const ctxTop = zoneCanvasTop.getContext('2d');
            const ctxBottom = zoneCanvasBottom.getContext('2d');
            
            // Clear both canvases
            ctxTop.clearRect(0, 0, zoneCanvasTop.width, zoneCanvasTop.height);
            ctxBottom.clearRect(0, 0, zoneCanvasBottom.width, zoneCanvasBottom.height);
            
            // Draw all server zones
            serverZones.forEach((zone, zoneIndex) => {
                if (zone.points && zone.points.length >= 3) {
                    // Determine which canvas to draw on based on zone points
                    const zoneCenterY = zone.points.reduce((sum, p) => sum + p.y, 0) / zone.points.length;
                    const isTopZone = isSplitFrame && zoneCenterY < splitY;
                    
                    const canvas = isTopZone ? zoneCanvasTop : zoneCanvasBottom;
                    const ctx = isTopZone ? ctxTop : ctxBottom;
                    
                    // Apply offset for bottom split
                    const offsetY = isSplitFrame && !isTopZone ? -splitY : 0;
                    
                    ctx.beginPath();
                    ctx.moveTo(zone.points[0].x, zone.points[0].y + offsetY);
                    
                    for (let i = 1; i < zone.points.length; i++) {
                        ctx.lineTo(zone.points[i].x, zone.points[i].y + offsetY);
                    }
                    
                    ctx.closePath();
                    
                    // Zone style based on breach status
                    const isBreach = zone.breach_active || false;
                    if (isBreach) {
                        ctx.fillStyle = 'rgba(255, 0, 0, 0.3)';
                        ctx.strokeStyle = '#ff0000';
                        ctx.lineWidth = 4;
                    } else {
                        ctx.fillStyle = 'rgba(0, 255, 255, 0.15)';
                        ctx.strokeStyle = '#00ffff';
                        ctx.lineWidth = 3;
                    }
                    
                    ctx.fill();
                    ctx.stroke();
                    
                    // Draw zone points
                    zone.points.forEach(point => {
                        ctx.beginPath();
                        ctx.arc(point.x, point.y + offsetY, 10, 0, 2 * Math.PI);
                        ctx.fillStyle = isBreach ? '#ff0000' : '#00ffff';
                        ctx.fill();
                        ctx.strokeStyle = '#ffffff';
                        ctx.lineWidth = 2;
                        ctx.stroke();
                    });
                    
                    // Draw breach text if active
                    if (isBreach) {
                        const centerX = zone.points.reduce((sum, p) => sum + p.x, 0) / zone.points.length;
                        const centerY = zone.points.reduce((sum, p) => sum + p.y, 0) / zone.points.length + offsetY;
                        
                        ctx.font = 'bold 28px Courier New';
                        ctx.fillStyle = '#ff0000';
                        ctx.textAlign = 'center';
                        ctx.fillText('!! BREACH !!', centerX, centerY);
                    }
                    
                    console.log(`[Zone] Drew zone ${zoneIndex} on ${isTopZone ? 'TOP' : 'BOTTOM'} canvas, breach: ${isBreach}`);
                }
            });
            
            // Draw current drawing zone (if any)
            if (zonePoints.length > 0) {
                // Determine which canvas based on zone points
                const zoneCenterY = zonePoints.reduce((sum, p) => sum + p.y, 0) / zonePoints.length;
                const isTopZone = isSplitFrame && zoneCenterY < splitY;
                
                const canvas = isTopZone ? zoneCanvasTop : zoneCanvasBottom;
                const ctx = isTopZone ? ctxTop : ctxBottom;
                
                // Apply offset for bottom split
                const offsetY = isSplitFrame && !isTopZone ? -splitY : 0;
                
                // Draw on canvas
                ctx.beginPath();
                ctx.moveTo(zonePoints[0].x, zonePoints[0].y + offsetY);
                
                for (let i = 1; i < zonePoints.length; i++) {
                    ctx.lineTo(zonePoints[i].x, zonePoints[i].y + offsetY);
                }
                
                if (zonePoints.length >= 3) {
                    ctx.closePath();
                    ctx.fillStyle = 'rgba(255, 255, 0, 0.15)';
                    ctx.fill();
                }
                
                ctx.strokeStyle = '#ffff00';
                ctx.lineWidth = 3;
                ctx.stroke();
                
                // Draw points
                zonePoints.forEach(point => {
                    ctx.beginPath();
                    ctx.arc(point.x, point.y + offsetY, 10, 0, 2 * Math.PI);
                    ctx.fillStyle = '#ffff00';
                    ctx.fill();
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                });
                
                console.log(`[Zone] Drawing ${zonePoints.length} points on ${isTopZone ? 'TOP' : 'BOTTOM'} canvas`);
            }
        }
        
        function updateVideoFeed(data) {
            const img = document.getElementById('video-feed');
            const zoneCanvasTop = document.getElementById('zone-canvas-top');
            const zoneCanvasBottom = document.getElementById('zone-canvas-bottom');
            const overlayCanvas = document.getElementById('overlay-canvas');
            
            // Load image first to get dimensions
            const tempImg = new Image();
            tempImg.onload = () => {
                // Update canvas sizes to match video frame
                if (tempImg.width !== canvasWidth || tempImg.height !== canvasHeight) {
                    videoNaturalWidth = tempImg.width;
                    videoNaturalHeight = tempImg.height;
                    canvasWidth = tempImg.width;
                    canvasHeight = tempImg.height;
                    
                    // Detect split frame (V380 vertical stack)
                    isSplitFrame = (tempImg.width < tempImg.height * 0.9);
                    splitY = Math.round(tempImg.height / 2);
                    topCanvasHeight = splitY;
                    bottomCanvasHeight = tempImg.height - splitY;
                    
                    if (isSplitFrame) {
                        // Top canvas: full width, half height
                        zoneCanvasTop.width = tempImg.width;
                        zoneCanvasTop.height = topCanvasHeight;
                        
                        // Bottom canvas: full width, half height
                        zoneCanvasBottom.width = tempImg.width;
                        zoneCanvasBottom.height = bottomCanvasHeight;
                        
                        console.log(`[Canvas] Split frame: ${tempImg.width}x${tempImg.height}`);
                        console.log(`[Canvas] Top: ${zoneCanvasTop.width}x${zoneCanvasTop.height} (top split)`);
                        console.log(`[Canvas] Bottom: ${zoneCanvasBottom.width}x${zoneCanvasBottom.height} (bottom split)`);
                        addLog(`Split frame: Top ${zoneCanvasTop.width}x${zoneCanvasTop.height}, Bottom ${zoneCanvasBottom.width}x${zoneCanvasBottom.height}`, 'info');
                    } else {
                        // Single camera
                        zoneCanvasTop.width = tempImg.width;
                        zoneCanvasTop.height = tempImg.height;
                        zoneCanvasBottom.width = tempImg.width;
                        zoneCanvasBottom.height = tempImg.height;
                        
                        console.log(`[Canvas] Single camera: ${tempImg.width}x${tempImg.height}`);
                        addLog(`Single camera: ${tempImg.width}x${tempImg.height}`, 'info');
                    }
                    
                    canvasWidth = tempImg.width;
                    canvasHeight = tempImg.height;
                    
                    // Overlay canvas always full size
                    overlayCanvas.width = tempImg.width;
                    overlayCanvas.height = tempImg.height;
                }
            };
            tempImg.src = `data:image/jpeg;base64,${data}`;
            
            // Data URL - no cache needed for data URLs
            img.src = `data:image/jpeg;base64,${data}`;
            
            // Redraw zones on each frame update
            setTimeout(() => {
                drawAllZones();
            }, 50);
        }
        
        function updateConnectionUI() {
            const statusEl = document.getElementById('connection-status');
            const alertEl = document.getElementById('connection-alert');
            
            if (connected) {
                statusEl.textContent = 'Connected';
                statusEl.className = 'status-value';
                alertEl.className = 'connection-status connected';
                alertEl.textContent = '‚úÖ Connected to server';
            } else {
                statusEl.textContent = 'Disconnected';
                statusEl.className = 'status-value danger';
                alertEl.className = 'connection-status disconnected';
                alertEl.textContent = '‚ö†Ô∏è Disconnected from server. Reconnecting...';
            }
        }
        
        function updateStatus(status) {
            document.getElementById('client-count').textContent = status.clients;
            document.getElementById('person-count').textContent = status.persons;
            document.getElementById('alert-count').textContent = status.alerts;
            document.getElementById('clients-stat').textContent = status.clients;
            
            // Arm status
            savedState.armed = status.armed;
            updateToggle('arm', status.armed);
            document.getElementById('arm-status-text').textContent = status.armed ? 'ARMED' : 'DISARMED';
            document.getElementById('arm-status-text').style.color = status.armed ? '#00ff00' : '#ff0000';
            
            // Recording status
            savedState.recording = status.recording;
            updateToggle('record', status.recording);
            document.getElementById('recording-status').textContent = status.recording ? 'On' : 'Off';
            document.getElementById('recording-status').className = status.recording ? 'status-value danger' : 'status-value';
            
            // Update status display outside live preview
            const armDisplay = document.getElementById('arm-status-display');
            armDisplay.textContent = status.armed ? 'ARMED' : 'DISARMED';
            armDisplay.className = 'status-text-large ' + (status.armed ? 'armed' : 'disarmed');
            
            // Recording status
            savedState.recording = status.recording;
            updateToggle('record', status.recording);
            document.getElementById('recording-status').textContent = status.recording ? 'On' : 'Off';
            document.getElementById('recording-status').className = status.recording ? 'status-value danger' : 'status-value';
            
            // Mute status
            savedState.muted = status.muted;
            updateToggle('mute', status.muted);
            
            // Zone breach status
            document.getElementById('zone-status').textContent = status.breach_active ? 'BREACH' : 'Clear';
            document.getElementById('zone-status').className = status.breach_active ? 'status-value danger' : 'status-value';
            document.getElementById('breach-duration').textContent = `${status.breach_duration}s`;
            document.getElementById('breach-duration-stat').textContent = `${status.breach_duration}s`;
            
            // Update breach duration display
            const breachDisplay = document.getElementById('breach-duration-display');
            breachDisplay.textContent = `${status.breach_duration}s`;
            if (status.breach_active) {
                breachDisplay.className = 'status-text-large breach';
            } else {
                breachDisplay.className = 'status-text-large';
            }
            
            // Update zone count display
            document.getElementById('zone-count-display').textContent = `${status.zones} zones`;
            
            // Detection features - save to localStorage
            savedState.skeleton = status.skeleton;
            savedState.face = status.face;
            savedState.motion = status.motion;
            savedState.heatmap = status.heatmap;
            savedState.night_vision = status.night_vision;
            
            updateToggle('skeleton', status.skeleton);
            updateToggle('face', status.face);
            updateToggle('motion', status.motion);
            updateToggle('heatmap', status.heatmap);
            updateToggle('night', status.night_vision);
            
            // Zone count
            document.getElementById('zone-count').textContent = `${status.zones} zones`;
            document.getElementById('zones-count-panel').textContent = status.zones || 0;
            document.getElementById('zone-points-count').textContent = zonePoints.length;
            
            // Faces count
            document.getElementById('faces-count').textContent = status.faces;
            
            // Model and confidence
            document.getElementById('confidence-select').value = status.confidence;
            document.getElementById('model-select').value = status.model;
            
            // Save state to localStorage
            saveState();
        }
        
        function updateToggle(name, enabled) {
            const indicator = document.getElementById(`${name}-indicator`);
            if (indicator) {
                if (enabled) {
                    indicator.classList.add('on');
                } else {
                    indicator.classList.remove('on');
                }
            }
        }
        
        function requestStatus() {
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({ type: 'get_status' }));
            }
        }
        
        function startFPSCounter() {
            if (fpsTimer) return;
            
            fpsTimer = setInterval(() => {
                const now = Date.now();
                const elapsed = (now - lastFrameTime) / 1000;
                const fps = Math.round(frameCount / elapsed);
                
                document.getElementById('fps-counter').textContent = fps;
                
                frameCount = 0;
                lastFrameTime = now;
            }, 1000);
        }
        
        function stopFPSCounter() {
            if (fpsTimer) {
                clearInterval(fpsTimer);
                fpsTimer = null;
            }
            document.getElementById('fps-counter').textContent = '0';
        }
        
        function addLog(message, type = 'info') {
            const container = document.getElementById('log-container');
            const now = new Date();
            const time = now.toLocaleTimeString();
            
            const entry = document.createElement('div');
            entry.className = `log-entry ${type}`;
            entry.innerHTML = `
                <span class="log-time">${time}</span>
                <span class="log-message">${message}</span>
            `;
            
            container.insertBefore(entry, container.firstChild);
            
            while (container.children.length > 100) {
                container.removeChild(container.lastChild);
            }
        }
        
        function sendCommand(type, data = {}) {
            if (ws && ws.readyState === WebSocket.OPEN) {
                const command = { type, ...data };
                console.log('[WebSocket] Sending command:', command);
                ws.send(JSON.stringify(command));
            } else {
                addLog('Not connected to server', 'error');
            }
        }
        
        // Controls - Apply saved state on first load
        function applySavedState() {
            console.log('[State] Applying saved state to UI:', savedState);
            
            // Apply to toggles
            updateToggle('arm', savedState.armed);
            updateToggle('record', savedState.recording);
            updateToggle('mute', savedState.muted);
            updateToggle('skeleton', savedState.skeleton);
            updateToggle('face', savedState.face);
            updateToggle('motion', savedState.motion);
            updateToggle('heatmap', savedState.heatmap);
            updateToggle('night', savedState.night_vision);
        }
        
        function toggleArm() {
            const currentState = document.getElementById('arm-indicator').classList.contains('on');
            const newState = !currentState;
            savedState.armed = newState;
            sendCommand('toggle_arm', { value: newState });
            updateToggle('arm', newState);
            saveState();
            addLog(`System ${newState ? 'ARMED' : 'DISARMED'}`, newState ? 'warning' : 'success');
        }
        
        function toggleRecord() {
            const currentState = document.getElementById('record-indicator').classList.contains('on');
            const newState = !currentState;
            savedState.recording = newState;
            sendCommand('toggle_record', { value: newState });
            updateToggle('record', newState);
            saveState();
            addLog(`Recording ${newState ? 'STARTED' : 'STOPPED'}`, newState ? 'warning' : 'success');
        }
        
        function takeSnapshot() {
            sendCommand('snapshot');
            addLog('Snapshot requested', 'info');
        }
        
        function toggleMute() {
            const currentState = document.getElementById('mute-indicator').classList.contains('on');
            const newState = !currentState;
            savedState.muted = newState;
            sendCommand('toggle_mute', { value: newState });
            updateToggle('mute', newState);
            saveState();
            addLog(`Alarm ${newState ? 'MUTED' : 'UNMUTED'}`, newState ? 'warning' : 'success');
        }
        
        function setConfidence() {
            const value = parseFloat(document.getElementById('confidence-select').value);
            sendCommand('set_confidence', { value });
            addLog(`Confidence set to ${(value * 100).toFixed(0)}%`, 'info');
        }
        
        function setModel() {
            const value = document.getElementById('model-select').value;
            sendCommand('set_model', { value });
            addLog(`Model changed to ${value}`, 'info');
        }
        
        function toggleSkeleton() {
            const currentState = document.getElementById('skeleton-indicator').classList.contains('on');
            const newState = !currentState;
            savedState.skeleton = newState;
            sendCommand('toggle_skeleton', { value: newState });
            updateToggle('skeleton', newState);
            saveState();
            addLog(`Skeleton detection ${newState ? 'ENABLED' : 'DISABLED'}`, 'info');
        }
        
        function toggleFace() {
            const currentState = document.getElementById('face-indicator').classList.contains('on');
            const newState = !currentState;
            savedState.face = newState;
            sendCommand('toggle_face', { value: newState });
            updateToggle('face', newState);
            saveState();
            addLog(`Face recognition ${newState ? 'ENABLED' : 'DISABLED'}`, 'info');
        }
        
        function toggleMotion() {
            const currentState = document.getElementById('motion-indicator').classList.contains('on');
            const newState = !currentState;
            savedState.motion = newState;
            sendCommand('toggle_motion', { value: newState });
            updateToggle('motion', newState);
            saveState();
            addLog(`Motion detection ${newState ? 'ENABLED' : 'DISABLED'}`, 'info');
        }
        
        function toggleHeatmap() {
            const currentState = document.getElementById('heatmap-indicator').classList.contains('on');
            const newState = !currentState;
            savedState.heatmap = newState;
            sendCommand('toggle_heatmap', { value: newState });
            updateToggle('heatmap', newState);
            saveState();
            addLog(`Heat map ${newState ? 'ENABLED' : 'DISABLED'}`, 'info');
        }
        
        function toggleNightVision() {
            const currentState = document.getElementById('night-indicator').classList.contains('on');
            const newState = !currentState;
            savedState.night_vision = newState;
            sendCommand('toggle_night_vision', { value: newState });
            updateToggle('night', newState);
            saveState();
            addLog(`Night vision ${newState ? 'ENABLED' : 'DISABLED'}`, 'info');
        }
        
        function createZone() {
            console.log('[Zone] Creating new zone...');
            sendCommand('create_zone');
            addLog('New zone created', 'success');
        }
        
        function toggleDrawMode() {
            isDrawing = !isDrawing;
            updateToggle('draw', isDrawing);
            
            const body = document.body;
            if (isDrawing) {
                body.classList.add('drawing-mode');
                zonePoints = []; // Reset current drawing
                addLog('Zone drawing mode ENABLED', 'warning');
            } else {
                body.classList.remove('drawing-mode');
                if (zonePoints.length >= 3) {
                    // Finalize zone - send to server
                    console.log('[Zone] Finalizing zone with', zonePoints.length, 'points');
                    // Server will create zone automatically when points are added
                    addLog(`Zone finalized with ${zonePoints.length} points`, 'success');
                }
                zonePoints = [];
                drawAllZones(); // Redraw to clear current drawing
                addLog('Zone drawing mode DISABLED', 'info');
            }
        }
        
        function addZonePoint(event, split = 'top') {
            const target = event.target;
            const rect = target.getBoundingClientRect();
            
            // Determine which canvas was clicked based on ID
            const isTopCanvas = target.id === 'zone-canvas-top';
            const isBottomCanvas = target.id === 'zone-canvas-bottom';
            
            if (isSplitFrame) {
                // Split frame mode
                if (isTopCanvas) {
                    // Top canvas clicked
                    const targetRect = rect; // Use rect from the clicked canvas
                    const scaleX = videoNaturalWidth / targetRect.width;
                    const scaleY = topCanvasHeight / targetRect.height;
                    
                    const x = Math.round((event.clientX - targetRect.left) * scaleX);
                    const y = Math.round((event.clientY - targetRect.top) * scaleY);
                    
                    console.log(`[Zone] Top canvas click: video=${videoNaturalWidth}x${videoNaturalHeight}, canvas=${zoneCanvasTop.width}x${zoneCanvasTop.height}, rect=${targetRect.width}x${targetRect.height}, scale=${scaleX.toFixed(2)}x${scaleY.toFixed(2)}, point=(${x}, ${y})`);
                    
                    // Send point with coordinates relative to top split (0 to splitY)
                    sendCommand('add_zone_point', { x, y });
                    zonePoints.push({ x, y });
                    drawAllZones();
                    addLog(`Zone point added (TOP split): (${x}, ${y})`, 'info');
                } else if (isBottomCanvas) {
                    // Bottom canvas clicked
                    const targetRect = rect; // Use rect from the clicked canvas
                    const scaleX = videoNaturalWidth / targetRect.width;
                    const scaleY = bottomCanvasHeight / targetRect.height;
                    
                    const x = Math.round((event.clientX - targetRect.left) * scaleX);
                    let y = Math.round((event.clientY - targetRect.top) * scaleY);
                    
                    // Adjust Y to be relative to bottom split (subtract splitY)
                    y = y - splitY;
                    
                    console.log(`[Zone] Bottom canvas click: video=${videoNaturalWidth}x${videoNaturalHeight}, canvas=${zoneCanvasBottom.width}x${zoneCanvasBottom.height}, rect=${targetRect.width}x${targetRect.height}, scale=${scaleX.toFixed(2)}x${scaleY.toFixed(2)}, point=(${x}, ${y})`);
                    
                    // Send point with coordinates relative to bottom split (negative Y, relative to splitY)
                    sendCommand('add_zone_point', { x, y });
                    zonePoints.push({ x, y });
                    drawAllZones();
                    addLog(`Zone point added (BOTTOM split): (${x}, ${y}) [relative to bottom split]`, 'info');
                }
            } else {
                // Single camera mode
                const targetRect = rect;
                const scaleX = videoNaturalWidth / targetRect.width;
                const scaleY = canvasHeight / targetRect.height;
                
                const x = Math.round((event.clientX - targetRect.left) * scaleX);
                const y = Math.round((event.clientY - targetRect.top) * scaleY);
                
                console.log(`[Zone] Single camera click: video=${videoNaturalWidth}x${videoNaturalHeight}, canvas=${zoneCanvasTop.width}x${zoneCanvasTop.height}, rect=${targetRect.width}x${targetRect.height}, scale=${scaleX.toFixed(2)}x${scaleY.toFixed(2)}, point=(${x}, ${y})`);
                
                sendCommand('add_zone_point', { x, y });
                zonePoints.push({ x, y });
                drawAllZones();
                addLog(`Zone point added: (${x}, ${y})`, 'info');
            }
        }
        
        function clearZones() {
            if (confirm('Are you sure you want to clear all zones?')) {
                sendCommand('clear_zones');
                addLog('All zones cleared', 'warning');
                
                // Clear both canvases
                const zoneCanvasTop = document.getElementById('zone-canvas-top');
                const zoneCanvasBottom = document.getElementById('zone-canvas-bottom');
                const ctxTop = zoneCanvasTop.getContext('2d');
                const ctxBottom = zoneCanvasBottom.getContext('2d');
                
                ctxTop.clearRect(0, 0, zoneCanvasTop.width, zoneCanvasTop.height);
                ctxBottom.clearRect(0, 0, zoneCanvasBottom.width, zoneCanvasBottom.height);
                
                zonePoints = [];
                drawAllZones();
            }
        }
        
        function reloadFaces() {
            sendCommand('reload_faces');
            addLog('Reloading trusted faces...', 'info');
        }
        
        function showSnapshot(data) {
            const modal = document.getElementById('snapshot-modal');
            const img = document.getElementById('snapshot-image');
            const time = document.getElementById('snapshot-time');
            
            img.src = `data:image/jpeg;base64,${data}`;
            time.textContent = `Captured at ${new Date().toLocaleString()}`;
            
            modal.classList.add('show');
            addLog('Snapshot received', 'success');
        }
        
        function closeSnapshotModal() {
            document.getElementById('snapshot-modal').classList.remove('show');
        }
        
        // Auto-refresh status every 5 seconds
        setInterval(() => {
            if (connected) {
                requestStatus();
            }
        }, 5000);
    </script>
</body>
</html>
